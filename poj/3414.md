[返回](https://github.com/superkunn/acmer)
## Pots
Time Limit: 1000MS		Memory Limit: 65536K
Total Submissions: 17686		Accepted: 7489		Special Judge
### Description

* You are given two pots, having the volume of A and B liters respectively. The following operations can be performed:

* FILL(i)        fill the pot i (1 ≤ i ≤ 2) from the tap;
* DROP(i)      empty the pot i to the drain;
* POUR(i,j)    pour from pot i to pot j; after this operation either the pot j is full (and there may be some water left in the pot i), or the pot i is empty (and all its contents have been moved to the pot j).

* Write a program to find the shortest possible sequence of these operations that will yield exactly C liters of water in one of the pots.

### Input

* On the first and only line are the numbers A, B, and C. These are all integers in the range from 1 to 100 and C≤max(A,B).

### Output

* The first line of the output must contain the length of the sequence of operations K. The following K lines must each describe one operation. If there are several sequences of minimal length, output any one of them. If the desired result can’t be achieved, the first and only line of the file must contain the word ‘impossible’.

### Sample Input
```
3 5 4
```
### Sample Output
```
6
FILL(2)
POUR(2,1)
DROP(1)
POUR(2,1)
FILL(2)
POUR(2,1)
```

```c++
#include <stdio.h>
#include <iostream>
#include <queue>
#include <cmath>
using namespace std;

struct node
{
    int x;
    int y;
    int step;
    int ssr[10000];
};

int v[101][101];


void bfs(int a,int b,int c )
{


    queue<node> Q;
    node aa,next;
    aa.x = 0;
    aa.y = 0;
    aa.step = 0;
    int i;
    for(i=0;i<10000;i++){
        aa.ssr[i]=0;
    }

    v[0][0]=1;

    Q.push(aa);

    while(!Q.empty()){
        //  cout<<Q.front().x<<endl;
        node tmp;
        tmp = Q.front();
      //  for(int i=1;i<=tmp.step;i++){
          //  tmp.ssr[i]=Q.front().ssr[i];
        //}

        //cout<<tmp.x<<" "<<tmp.y<<" "<<tmp.ssr[tmp.step]<<endl;
        Q.pop();




        if(tmp.x == c||tmp.y == c){
            cout<<tmp.step<<endl;
            //    cout<<tmp.x<<" "<<tmp.y<<" "<<tmp.ssr[tmp.step]<<endl;
         //   for(int i = 1;i<=tmp.step;i++){
         //       cout<<tmp.ssr[i]<<endl;
       //     }
            int j=1;
            while(tmp.ssr[j]){
                switch(tmp.ssr[j]){
                case 1:
                    cout<<"FILL(1)"<<endl;
                    break;
                case 2:
                    cout<<"FILL(2)"<<endl;
                    break;
                 case 3:
                    cout<<"DROP(1)"<<endl;
                    break;
                case 4:
                    cout<<"DROP(2)"<<endl;
                    break;
                case 5:
                    cout<<"POUR(2,1)"<<endl;
                    break;
                 case 6:
                    cout<<"POUR(1,2)"<<endl;
                    break;
                }

                j++;

            }
            return ;
        }
        else{
            next.x = a;
            next.y = tmp.y;
            next.step = tmp.step + 1;
            if(v[next.x][next.y] == 0){
                for(int i=1;i<=tmp.step;i++){
                    next.ssr[i]=tmp.ssr[i];
                }

                next.ssr[next.step] = 1;
                Q.push(next);
                v[next.x][next.y]=1;

            }

            next.x = tmp.x;
            next.y = b;
            if(v[next.x][next.y] == 0){
                for(int i=1;i<=tmp.step;i++){
                    next.ssr[i]=tmp.ssr[i];
                }

                next.ssr[next.step] = 2;
                Q.push(next);
                v[next.x][next.y]=1;
            }

            next.x = 0;
            next.y = tmp.y;
            if(v[next.x][next.y] == 0){
                for(int i=1;i<=tmp.step;i++){
                    next.ssr[i]=tmp.ssr[i];
                }
                next.ssr[next.step] = 3;
                Q.push(next);
                v[next.x][next.y]=1;
            }

            next.x = tmp.x;
            next.y = 0;
            if(v[next.x][next.y] == 0){
                for(int i=1;i<=tmp.step;i++){
                    next.ssr[i]=tmp.ssr[i];
                }
                next.ssr[next.step] = 4;
                Q.push(next);
                v[next.x][next.y]=1;
            }


                next.x = (tmp.x+tmp.y)>a?a:(tmp.x+tmp.y);
                next.y = (tmp.x+tmp.y)>a?tmp.y-(a-tmp.x):0;
                if(v[next.x][next.y] == 0){
                    for(int i=1;i<=tmp.step;i++){
                        next.ssr[i]=tmp.ssr[i];
                    }
                    next.ssr[next.step] = 5;
                    Q.push(next);
                    v[next.x][next.y]=1;
                }

                next.y = tmp.y+tmp.x>b?b:tmp.y+tmp.x;
                next.x = tmp.y+tmp.x>b?tmp.x-(b-tmp.y):0;
                if(v[next.x][next.y] == 0){
                    for(int i=1;i<=tmp.step;i++){
                        next.ssr[i]=tmp.ssr[i];
                    }
                    next.ssr[next.step] = 6;
                    Q.push(next);
                v[next.x][next.y]=1;
            }


        }


    }

    cout<<"impossible"<<endl;


}

int main()
{
    int a,b,c;
    cin>>a>>b>>c;

    bfs(a,b,c);


    return 0;
}

```

[返回](https://github.com/superkunn/acmer)
